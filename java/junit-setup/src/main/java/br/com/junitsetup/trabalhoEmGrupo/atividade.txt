Sobre a matéria de estrutura de dados, faça os quatro métodos de ordenação abaixo implementados em java.

1- método da bolha;
2- método da bolha otimizado;
3- ordenação por inserção;
4- ordenação por seleção;

Para cada um dos métodos acima, incluir funcionalidade que calcule a:
- quantidade de comparações;
- quantidade de trocas;
- tempo de execução;

Crie o seguinte vetor V: [0,1000,5000,10000,15000,20000,25000,30000,35000,40000,45000,50000]
Crie também um método gerador de vetores que use o número de cada posição do vetor V para gerar os seguintes vetores:

A- vetor ordenado ascendente;
B- vetor ordenado descendente;
C- vetor de números aleatórios;

Execuções do método main:
-----------------------
Execute o método da bolha N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de comparações para N vezes;

Execute o método da bolha N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de trocas para N vezes;

Execute o método da bolha N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo o tempo de execução para N vezes;
------------------------
Execute o método da bolha otimizada N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de comparações para N vezes;

Execute o método da bolha otimizada N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de trocas para N vezes;

Execute o método da bolha otimizada N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo o tempo de execução para N vezes;
------------------------
Execute o método da ordenação por inserção N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de comparações para N vezes;

Execute o método da ordenação por inserção N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de trocas para N vezes;

Execute o método da ordenação por inserção N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo o tempo de execução para N vezes;
------------------------
Execute o método da ordenação por seleção N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de comparações para N vezes;

Execute o método da ordenação por seleção N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo a quantidade de trocas para N vezes;

Execute o método da ordenação por seleção N vezes para cada uma das posições do vetor V, sendo N o número que está na posição atual do vetor V.
Imprima no console duas colunas, a primeira contendo o valor que está na posição atual do vetor V em cada linha e na segunda coluna contendo o tempo de execução para N vezes;


--------
Expplicação

Vamos começar detalhando a implementação e o plano em pseudocódigo para essa tarefa. A ideia é implementar os quatro algoritmos de ordenação solicitados (bolha, bolha otimizada, inserção, seleção) com os requisitos de contagem de comparações, trocas e medição de tempo.

### Pseudocódigo:

1. **Método da Bolha**:
    - Implementar o algoritmo clássico da bolha.
    - Adicionar contadores para comparações e trocas.
    - Medir o tempo de execução usando `System.nanoTime()`.
    
2. **Método da Bolha Otimizada**:
    - Igual ao da bolha, mas com uma verificação de otimização para parar o loop caso o array já esteja ordenado.
    
3. **Método de Inserção**:
    - Implementar o algoritmo clássico de inserção.
    - Adicionar contadores para comparações e trocas.
    - Medir o tempo de execução.
    
4. **Método de Seleção**:
    - Implementar o algoritmo clássico de seleção.
    - Adicionar contadores para comparações e trocas.
    - Medir o tempo de execução.
    
5. **Geração dos vetores**:
    - Criar métodos para gerar três tipos de vetores: ordenado ascendente, descendente e aleatório.
    
6. **Execução principal**:
    - Para cada posição do vetor V, rodar cada algoritmo N vezes (onde N é o valor em V).
    - Exibir no console a quantidade de comparações, trocas e o tempo para cada execução.

### Implementação completa em Java:

```java
import java.util.Arrays;
import java.util.Random;

public class SortingTest {
    public static void main(String[] args) {
        int[] V = {0, 1000, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000};

        for (int n : V) {
            if (n == 0) continue;
            int[] asc = generateAscendingArray(n);
            int[] desc = generateDescendingArray(n);
            int[] random = generateRandomArray(n);

            // Bubble Sort
            System.out.println("Bubble Sort for N = " + n);
            runBubbleSortTests(n, asc, desc, random);
            
            // Optimized Bubble Sort
            System.out.println("Optimized Bubble Sort for N = " + n);
            runOptimizedBubbleSortTests(n, asc, desc, random);
            
            // Insertion Sort
            System.out.println("Insertion Sort for N = " + n);
            runInsertionSortTests(n, asc, desc, random);
            
            // Selection Sort
            System.out.println("Selection Sort for N = " + n);
            runSelectionSortTests(n, asc, desc, random);
        }
    }

    // Bubble Sort
    public static void bubbleSort(int[] arr, Result result) {
        int n = arr.length;
        result.comparisons = 0;
        result.swaps = 0;

        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                result.comparisons++;
                if (arr[j] > arr[j + 1]) {
                    result.swaps++;
                    swap(arr, j, j + 1);
                }
            }
        }
    }

    // Optimized Bubble Sort
    public static void optimizedBubbleSort(int[] arr, Result result) {
        int n = arr.length;
        result.comparisons = 0;
        result.swaps = 0;
        boolean swapped;

        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                result.comparisons++;
                if (arr[j] > arr[j + 1]) {
                    result.swaps++;
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            if (!swapped) break;  // If no swaps, array is already sorted
        }
    }

    // Insertion Sort
    public static void insertionSort(int[] arr, Result result) {
        int n = arr.length;
        result.comparisons = 0;
        result.swaps = 0;

        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                result.comparisons++;
                arr[j + 1] = arr[j];
                j--;
                result.swaps++;
            }
            arr[j + 1] = key;
        }
    }

    // Selection Sort
    public static void selectionSort(int[] arr, Result result) {
        int n = arr.length;
        result.comparisons = 0;
        result.swaps = 0;

        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < n; j++) {
                result.comparisons++;
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                result.swaps++;
                swap(arr, i, minIdx);
            }
        }
    }

    // Helper method to swap array elements
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // Method to run Bubble Sort tests
    public static void runBubbleSortTests(int n, int[] asc, int[] desc, int[] random) {
        testAlgorithm(n, "Bubble Sort Ascending", SortingTest::bubbleSort, asc);
        testAlgorithm(n, "Bubble Sort Descending", SortingTest::bubbleSort, desc);
        testAlgorithm(n, "Bubble Sort Random", SortingTest::bubbleSort, random);
    }

    // Method to run Optimized Bubble Sort tests
    public static void runOptimizedBubbleSortTests(int n, int[] asc, int[] desc, int[] random) {
        testAlgorithm(n, "Optimized Bubble Sort Ascending", SortingTest::optimizedBubbleSort, asc);
        testAlgorithm(n, "Optimized Bubble Sort Descending", SortingTest::optimizedBubbleSort, desc);
        testAlgorithm(n, "Optimized Bubble Sort Random", SortingTest::optimizedBubbleSort, random);
    }

    // Method to run Insertion Sort tests
    public static void runInsertionSortTests(int n, int[] asc, int[] desc, int[] random) {
        testAlgorithm(n, "Insertion Sort Ascending", SortingTest::insertionSort, asc);
        testAlgorithm(n, "Insertion Sort Descending", SortingTest::insertionSort, desc);
        testAlgorithm(n, "Insertion Sort Random", SortingTest::insertionSort, random);
    }

    // Method to run Selection Sort tests
    public static void runSelectionSortTests(int n, int[] asc, int[] desc, int[] random) {
        testAlgorithm(n, "Selection Sort Ascending", SortingTest::selectionSort, asc);
        testAlgorithm(n, "Selection Sort Descending", SortingTest::selectionSort, desc);
        testAlgorithm(n, "Selection Sort Random", SortingTest::selectionSort, random);
    }

    // Generic test runner for any sorting algorithm
    public static void testAlgorithm(int n, String testName, SortAlgorithm algorithm, int[] originalArray) {
        Result result = new Result();
        long totalTime = 0;
        for (int i = 0; i < n; i++) {
            int[] arrCopy = Arrays.copyOf(originalArray, originalArray.length);
            long startTime = System.nanoTime();
            algorithm.sort(arrCopy, result);
            long endTime = System.nanoTime();
            totalTime += (endTime - startTime);
        }

        System.out.printf("%s: Comparisons = %d, Swaps = %d, Time = %d ns%n",
                testName, result.comparisons, result.swaps, totalTime / n);
    }

    // Functional interface for sorting algorithms
    interface SortAlgorithm {
        void sort(int[] arr, Result result);
    }

    // Class to hold result data (comparisons and swaps)
    static class Result {
        int comparisons;
        int swaps;
    }

    // Methods to generate different types of arrays
    public static int[] generateAscendingArray(int n) {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = i;
        }
        return arr;
    }

    public static int[] generateDescendingArray(int n) {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    public static int[] generateRandomArray(int n) {
        Random random = new Random();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = random.nextInt(n);
        }
        return arr;
    }
}
```

### Explicação:
1. **Algoritmos de ordenação**:
    - Cada algoritmo (Bolha, Bolha Otimizada, Inserção e Seleção) foi implementado

 com contadores de comparações e trocas.
    - O tempo de execução é medido usando `System.nanoTime()`.

2. **Testes**:
    - Cada algoritmo é executado para os três tipos de arrays (ordenado ascendente, descendente e aleatório).
    - Para cada valor de `n` em `V`, os algoritmos são executados `n` vezes, e os resultados médios de comparações, trocas e tempo são impressos.

3. **Geração de arrays**:
    - Há três métodos para gerar arrays: ordenado ascendente, ordenado descendente e aleatório.

**a.** Adicionar suporte a paralelismo para execução mais rápida?